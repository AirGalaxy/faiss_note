# Fassi源码阅读
## 1.暴力检索的Index
### 1.1 IndexFlatCodes实现
Index有直接子类IndexFlatCodes，还记的上次我们说的Index类并没有给出具体存储的实现，IndexFlatCodes类就给出了一个简单的实现

### 1.2 IndexFlatCodes的成员变量
```c++
    //每个向量占用code_size个uint8_t
    size_t code_size;

    /// encoded dataset, size ntotal * code_size
    // 以一个vector存储所有的向量
    std::vector<uint8_t> codes;
```

### 1.3 IndexFlatCodes的成员函数
```c++
void IndexFlatCodes::add(idx_t n, const float* x) {
    FAISS_THROW_IF_NOT(is_trained);
    if (n == 0) {
        return;
    }
    codes.resize((ntotal + n) * code_size);
    sa_encode(n, x, codes.data() + (ntotal * code_size));
    ntotal += n;
}
```
先预分配(ntotal + n) * code_size个大小的空间，最后通过sa_encode(n, x, codes.data() + (ntotal * code_size))，直接将(n,x)放到codes.data()的尾部。当然IndexFlatCodes并没有实现sa_encode这个接口，一个朴素的实现可以直接调用``memcpy()``实现

```c++
void IndexFlatCodes::reset() {
    codes.clear();
    ntotal = 0;
}
```
清空所有向量，很简单不解释

```c++
size_t IndexFlatCodes::remove_ids(const IDSelector& sel) {
    idx_t j = 0;
    for (idx_t i = 0; i < ntotal; i++) {
        if (sel.is_member(i)) {
            // should be removed
        } else {
            if (i > j) {
                memmove(&codes[code_size * j],
                        &codes[code_size * i],
                        code_size);
            }
            //j记录了
            j++;
        }
    }
    size_t nremove = ntotal - j;
    if (nremove > 0) {
        ntotal = j;
        codes.resize(ntotal * code_size);
    }
    return nremove;
}
```
实现了从codes中移除元素，如果i不需要移除，则i=j，不进行任何操作，若出现一个需要移除的元素，则i = i+1，而j不变，在下一次循环时，将下一个元素向前移动一位，移动到j的位置上，以此类推。最后resize codes这个vector的大小。
由此也可以看出，删除IndexFlatCodes中的元素开销是很大的，或许业务方使用标记删除会更好。

```c++
void IndexFlatCodes::merge_from(Index& otherIndex, idx_t add_id) {
    FAISS_THROW_IF_NOT_MSG(add_id == 0, "cannot set ids in FlatCodes index");
    check_compatible_for_merge(otherIndex);
    IndexFlatCodes* other = static_cast<IndexFlatCodes*>(&otherIndex);
    codes.resize((ntotal + other->ntotal) * code_size);
    memcpy(codes.data() + (ntotal * code_size),
           other->codes.data(),
           other->ntotal * code_size);
    ntotal += other->ntotal;
    other->reset();
}

```
合并两个index也很简单，memcpy直接把other里的数组直接copy过去，之后释放other的数组

## 2.暴力检索-IndexFlat的实现
### 2.1 IndexFlat概述
IndexFlat是IndexFlatCodes的子类，同时支持多种Metric。
### 2.2 IndexFlat的搜索方法
函数定义如下:
```c++
void IndexFlat::search(
        idx_t n,
        const float* x,
        idx_t k,
        float* distances,
        idx_t* labels,
        const SearchParameters* params) const {
    IDSelector* sel = params ? params->sel : nullptr;
    FAISS_THROW_IF_NOT(k > 0);

    // we see the distances and labels as heaps
    if (metric_type == METRIC_INNER_PRODUCT) {
        float_minheap_array_t res = {size_t(n), size_t(k), labels, distances};
        knn_inner_product(x, get_xb(), d, n, ntotal, &res, sel);
    } else if (metric_type == METRIC_L2) {
       ...
    }
}
```
代码结构很清晰，不同的Metric走不同的路线。不同的路线进行搜索的实现的也类似，先建立一个最小堆，然后进行knn的搜索。
```c++
typedef HeapArray<CMin<float, int64_t>> float_minheap_array_t;
```
float_minheap_array_t是一个模板类的特化，其实现是在HeapArray类中，通过名字我们就可以看出，这是一个通过数组实现的堆

